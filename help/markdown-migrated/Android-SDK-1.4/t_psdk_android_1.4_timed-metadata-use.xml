<?xml version="1.0"?>
<!DOCTYPE task PUBLIC "-//OASIS//DTD DITA Task//EN" "task.dtd">
<task id="task_timed_metadata_use"> 
  <title>Use timed metadata</title> 
  <shortdesc>You can use 
	 <codeph>TimedMetadata</codeph> when the current playback time matches the
	 start time. 
  </shortdesc> 
  <taskbody> 
	 <context id="context_362A0F8587794B4E816E954C8A17C07F"> 
		<p>To use these saved <codeph>TimedMetadata</codeph> objects during playback, use the saved
					<codeph>ArrayList</codeph> from <xref
					href="t_psdk_android_1.4_timed-metadata-store.xml#task_timed_metadata_store"
					format="dita" scope="local">Store timed-metadata objects as they are
					dispatched</xref>. </p> 
	 </context> 
	 <steps id="steps_A0EC034941464379AB3D7A5FDAF9026D"> 
		<step id="step_B0B98653A1564FB183DD500F56DF4C79">
				<cmd>Run a timer and repeatedly query the current playback time. </cmd>
			</step> 
		<step id="step_9A8B9EF41F084917A83029436A7FC07A">
				<cmd>Find all of the <codeph>TimedMetadata</codeph> objects with start times that
					match the current playback time. </cmd>
				<info>
					<p>You can use these objects to complete various actions. </p>
					<p>
						<note type="important">When checking whether the current playback time
							matches any <codeph>TimedMetadata</codeph> objects, include
								<codeph>shouldTriggerSubscribedTagEvent</codeph> as a condition.
						</note>
					</p>
					<p>The timeline might change as the result of various ad behaviors. For example,
						one or more ad breaks might be moved from their original positions on the
						timeline, but <codeph>shouldTriggerSubscribedTagEvent</codeph> ensures that
						the <codeph>TimeMetadata</codeph> object's start time matches the current
						playback time. </p>
					<p>For example:
						<codeblock outputclass="syntax java">_playbackClockEventListener = new Clock.ClockEventListener() {
    @Override
    public void onTick(String name) {
        getActivity().runOnUiThread(new Runnable() {
            @Override
            public void run() {
                         
                /* handle timedmetadata object list  */
                if (_mediaPlayer != null &amp;&amp; _timedMetadataList != null &amp;&amp; _timedMetadataList.size() &gt; 0) {
                    if (_lastKnownStatus == MediaPlayer.PlayerState.PLAYING) {
                        long localTime = _mediaPlayer.getLocalTime();
                        Iterator&lt;TimedMetadata&gt; iterator = _timedMetadataList.iterator();
                        while (iterator.hasNext()) {
                            TimedMetadata timedMetadata = iterator.next();
                            long diff = localTime - timedMetadata.getTime();
                            if (diff &gt;= 0 &amp;&amp;
                                diff &lt;= PLAYBACK_CLOCK_INTERVAL &amp;&amp;
                                _mediaPlayer.shouldTriggerSubscribedTagEvent()) {
 
                                // use timed metadata object
                            }
                        }
                    }
                }
            }
        });
    }
};
 
_playbackClock.addClockEventListener(_playbackClockEventListener);</codeblock>
					</p>
				</info>
			</step> 
		<step id="step_0813D4BE24B04A31821BFF7A5371DCA6">
				<cmd>Periodically flush stale <codeph>TimedMetadata</codeph> instances from the list
					to prevent memory from continuously growing. </cmd>
			</step> 
	 </steps> 
  </taskbody> 
</task> 
